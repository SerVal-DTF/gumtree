Previous File: OUTPUT/commons-io/prevFiles/prev_cbc5a1src#main#java#org#apache#commons#io#input#CharSequenceInputStream.java
Revised File: OUTPUT/commons-io/revFiles/cbc5a1src#main#java#org#apache#commons#io#input#CharSequenceInputStream.java
DiffEntry: @@ -23,2 +23,3 @@
 import java.nio.CharBuffer;
+import java.nio.InvalidMarkException;
 import java.nio.charset.CharacterCodingException;

@@ -49,3 +50,4 @@
 
-    private int mark;
+    private int mark_cbuf; // position in cbuf
+    private int mark_bbuf; // position in bbuf
     

@@ -72,3 +74,4 @@
         this.cbuf = CharBuffer.wrap(cs);
-        this.mark = NO_MARK;
+        this.mark_cbuf = NO_MARK;
+        this.mark_bbuf = NO_MARK;
     }

@@ -180,5 +183,8 @@
     public long skip(long n) throws IOException {
+        /*
+         * This could be made more efficient by using position to skip within the current buffer.
+         */
         long skipped = 0;
-        while (n > 0 && this.cbuf.hasRemaining()) {
-            this.cbuf.get();
+        while (n > 0 && available() > 0) {
+            this.read();
             n--;

@@ -214,3 +220,8 @@
     public synchronized void mark(final int readlimit) {
-        this.mark = this.cbuf.position();
+        this.mark_cbuf = this.cbuf.position();
+        this.mark_bbuf = this.bbuf.position();
+        this.cbuf.mark();
+        this.bbuf.mark();
+        // It would be nice to be able to use mark & reset on the cbuf and bbuf;
+        // however the bbuf is re-used so that won't work
     }

@@ -219,7 +230,31 @@
     public synchronized void reset() throws IOException {
-        if (this.mark != NO_MARK) {
-            this.cbuf.position(this.mark);
-            this.mark = NO_MARK;
-            this.bbuf.limit(0);
-            this.encoder.reset();
+        /*
+         * This is not the most efficient implementation, as it re-encodes from the beginning.
+         *
+         * Since the bbuf is re-used, in general it's necessary to re-encode the data.
+         *
+         * It should be possible to apply some optimisations however:
+         * + use mark/reset on the cbuf and bbuf. This would only work if the buffer had not been (re)filled since the mark.
+         * The code would have to catch InvalidMarkException - does not seem possible to check if mark is valid otherwise.
+         * + Try saving the state of the cbuf before each fillBuffer; it might be possible to restart from there.
+         */
+        if (this.mark_cbuf != NO_MARK) {
+            // if cbuf is at 0, we have not started reading anything, so skip re-encoding
+            if (this.cbuf.position() != 0) {
+                this.encoder.reset();
+                this.cbuf.rewind();
+                this.bbuf.rewind();
+                this.bbuf.limit(0); // rewind does not clear the buffer
+                while(this.cbuf.position() < this.mark_cbuf) {
+                    this.bbuf.rewind(); // empty the buffer (we only refill when empty during normal processing)
+                    this.bbuf.limit(0);
+                    fillBuffer();
+                }
+            }
+            if (this.cbuf.position() != this.mark_cbuf) {
+                throw new IllegalStateException("Unexpected CharBuffer postion: actual="+cbuf.position() + " expected=" + this.mark_cbuf);
+            }
+            this.bbuf.position(this.mark_bbuf);                
+            this.mark_cbuf = NO_MARK;
+            this.mark_bbuf = NO_MARK;
         }

