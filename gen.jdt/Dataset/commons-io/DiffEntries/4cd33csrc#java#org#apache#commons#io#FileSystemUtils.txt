Previous File: OUTPUT/commons-io/prevFiles/prev_4cd33csrc#java#org#apache#commons#io#FileSystemUtils.java
Revised File: OUTPUT/commons-io/revFiles/4cd33csrc#java#org#apache#commons#io#FileSystemUtils.java
DiffEntry: @@ -18,4 +18,5 @@
 import java.io.BufferedReader;
-import java.io.IOException;
 import java.io.InputStreamReader;
+import java.io.IOException;
+import java.util.ArrayList;
 import java.util.StringTokenizer;

@@ -32,9 +33,17 @@
  */
-public final class FileSystemUtils {
+public class FileSystemUtils {
 
+    /** Singleton instance, used mainly for testing. */
+    private static final FileSystemUtils INSTANCE = new FileSystemUtils();
+
+    /** Operating system state flag for error. */
     private static final int INIT_PROBLEM = -1;
+    /** Operating system state flag for neither Unix nor Windows. */
     private static final int OTHER = 0;
+    /** Operating system state flag for Windows. */
     private static final int WINDOWS = 1;
+    /** Operating system state flag for Unix. */
     private static final int UNIX = 2;
 
+    /** The operating system flag. */
     private static final int OS;

@@ -67,3 +76,3 @@
             }
-            
+
         } catch (Exception ex) {

@@ -78,5 +87,5 @@
     public FileSystemUtils() {
+        super();
     }
 
-    //-----------------------------------------------------------------------
     /**

@@ -89,5 +98,5 @@
      * The free space is calculated via the command line.
-     * It uses 'dir /-c' on Windows and 'df' on Unix.
+     * It uses 'dir /-c' on Windows and 'df' on *nix.
      *
-     * @param path  the path to get free space for
+     * @param path  the path to get free space for, not null, not empty on Unix
      * @return the amount of free drive space on the drive or volume

@@ -98,6 +107,26 @@
     public static long getFreeSpace(String path) throws IOException {
-        if (path == null || path.length() == 0) {
+        return INSTANCE.getFreeSpaceOS(path, OS);
+    }
+
+    /**
+     * Returns the free space on a drive or volume in a cross-platform manner.
+     * Note that some OS's are NOT currently supported, including OS/390.
+     * <pre>
+     * FileSystemUtils.getFreeSpace("C:");  // Windows
+     * FileSystemUtils.getFreeSpace("/volume");  // *nix
+     * </pre>
+     * The free space is calculated via the command line.
+     * It uses 'dir /-c' on Windows and 'df' on *nix.
+     *
+     * @param path  the path to get free space for, not null, not empty on Unix
+     * @return the amount of free drive space on the drive or volume
+     * @throws IllegalArgumentException if the path is invalid
+     * @throws IllegalStateException if an error occurred in initialisation
+     * @throws IOException if an error occurs when finding the free space
+     */
+    protected long getFreeSpaceOS(String path, int os) throws IOException {
+        if (path == null) {
             throw new IllegalArgumentException("Path must not be empty");
         }
-        switch (OS) {
+        switch (os) {
             case WINDOWS:

@@ -109,3 +138,4 @@
             default:
-                throw new IllegalStateException("Exception caught when determining operating system");
+                throw new IllegalStateException(
+                  "Exception caught when determining operating system");
         }

@@ -120,33 +150,21 @@
      */
-    private static long getFreeSpaceWindows(String path) throws IOException {
-        // build and run the 'dir' command
-        String line = null;
-        String[] cmdAttrbs = new String[3];
-        cmdAttrbs[0] = "cmd.exe";
-        cmdAttrbs[1] = "/C";
-        cmdAttrbs[2] = "dir /-c " + path;
-        Process proc = Runtime.getRuntime().exec(cmdAttrbs);
+    protected long getFreeSpaceWindows(String path) throws IOException {
+        path = FilenameUtils.normalize(path);
+        if (path.length() > 2 && path.charAt(1) == ':') {
+            path = path.substring(0, 2);
+        }
 
-        // read the output until we find the line with 'bytes free'
-        long bytes = -1;
+        // build and run the 'dir' command
+        String[] cmdAttrbs = new String[] {"cmd.exe", "/C", "dir /c " + path};
+
+        // read in the output of the command to an ArrayList
         BufferedReader in = null;
+        String line = null;
+        ArrayList lines = new ArrayList();
         try {
-            in = new BufferedReader(new InputStreamReader(proc.getInputStream()));
+            in = openProcessStream(cmdAttrbs);
             line = in.readLine();
             while (line != null) {
-                line = line.toLowerCase();
-                int bfl = line.indexOf("bytes free");
-                if (bfl != -1) {
-                    // found "bytes free"
-                    // chop off everything AFTER the actual byte count
-                    line = line.substring(0, bfl);
-                    line = line.trim();
-                    // find the LAST space in the string, should be right before the
-                    // byte count
-                    int lsl = line.lastIndexOf(' ');
-                    // now get rid of everything BEFORE that space, and line will
-                    // then contain just the byte count
-                    line = line.substring(lsl + 1);
-                    bytes = Long.parseLong(line);
-                }
+                line = line.toLowerCase().trim();
+                lines.add(line);
                 line = in.readLine();

@@ -157,7 +175,58 @@
 
-        if (bytes == -1) {
+        if (lines.size() == 0) {
+            // unknown problem, throw exception
             throw new IOException(
-                    "Command line 'dir' did not find text 'bytes free' in response for path '" +
-                    path + "'- check path is of the form 'C:'");
+                    "Command line 'dir /c' did not return any info " +
+                    "for command '" + cmdAttrbs[2] + "'");
         }
+
+        // now iterate over the lines we just read and find the LAST
+        // non-empty line (the free space bytes should be in the last element
+        // of the ArrayList anyway, but this will ensure it works even if it's
+        // not, still assuming it is on the last non-blank line)
+        long bytes = -1;
+        int i = lines.size() - 1;
+        int bytesStart = 0;
+        int bytesEnd = 0;
+        outerLoop: while (i > 0) {
+            line = (String) lines.get(i);
+            if (line.length() > 0) {
+                // found it, so now read from the end of the line to find the
+                // last numeric character on the line, then continue until we
+                // find the first non-numeric character, and everything between
+                // that and the last numeric character inclusive is our free
+                // space bytes count
+                int j = line.length() - 1;
+                innerLoop1: while (j >= 0) {
+                    char c = line.charAt(j);
+                    if (Character.isDigit(c)) {
+                      // found the last numeric character, this is the end of
+                      // the free space bytes count
+                      bytesEnd = j + 1;
+                      break innerLoop1;
+                    }
+                    j--;
+                }
+                innerLoop2: while (j >= 0) {
+                    char c = line.charAt(j);
+                    if (!Character.isDigit(c) && c != ',' && c != '.') {
+                      // found the next non-numeric character, this is the
+                      // beginning of the free space bytes count
+                      bytesStart = j + 1;
+                      break innerLoop2;
+                    }
+                    j--;
+                }
+                break outerLoop;
+            }
+        }
+
+        // remove commas and dots in the bytes count
+        StringBuffer buf = new StringBuffer(line.substring(bytesStart, bytesEnd));
+        for (int k = 0; k < buf.length(); k++) {
+            if (buf.charAt(k) == ',' || buf.charAt(k) == '.') {
+                buf.deleteCharAt(k--);
+            }
+        }
+        bytes = Long.parseLong(buf.toString());
         return bytes;

@@ -166,3 +235,3 @@
     /**
-     * Find free space on the Nix platform using the 'df' command.
+     * Find free space on the *nix platform using the 'df' command.
      *

@@ -172,9 +241,10 @@
      */
-    private static long getFreeSpaceUnix(String path) throws IOException {
+    protected long getFreeSpaceUnix(String path) throws IOException {
+        if (path.length() == 0) {
+            throw new IllegalArgumentException("Path must not be empty");
+        }
+        path = FilenameUtils.normalize(path);
+
         // build and run the 'dir' command
-        String[] cmdAttrbs = new String[3];
-        cmdAttrbs[0] = "cmd.exe";
-        cmdAttrbs[1] = "/C";
-        cmdAttrbs[2] = "df " + path;
-        Process proc = Runtime.getRuntime().exec(cmdAttrbs);
+        String[] cmdAttribs = new String[] {"df", path};
 

@@ -184,5 +254,6 @@
         try {
-            in = new BufferedReader(new InputStreamReader(proc.getInputStream()));
+            in = openProcessStream(cmdAttribs);
             String line1 = in.readLine(); // header line (ignore it)
             String line2 = in.readLine(); // the line we're interested in
+            String line3 = in.readLine(); // possibly interesting line
             if (line2 == null) {

@@ -190,4 +261,5 @@
                 throw new IOException(
-                        "Command line 'df' did not return info as expected for path '" +
-                        path + "'- response on first line was '" + line1 + '"');
+                        "Command line 'df' did not return info as expected " +
+                        "for path '" + path +
+                        "'- response on first line was '" + line1 + "'");
             }

@@ -198,7 +270,14 @@
             if (tok.countTokens() < 4) {
-                throw new IOException(
-                        "Command line 'df' did not return data as expected for path '" +
-                        path + "'- check path is valid");
+                // could be long Filesystem, thus data on third line
+                if (tok.countTokens() == 1 && line3 != null) {
+                    line3 = line3.trim();
+                    tok = new StringTokenizer(line3, " ");
+                } else {
+                    throw new IOException(
+                            "Command line 'df' did not return data as expected " +
+                            "for path '" + path + "'- check path is valid");
+                }
+            } else {
+                tok.nextToken(); // Ignore Filesystem
             }
-            tok.nextToken(); // Ignore Filesystem
             tok.nextToken(); // Ignore 1K-blocks

@@ -206,3 +285,9 @@
             String freeSpace = tok.nextToken();
-            bytes = Long.parseLong(freeSpace);
+            try {
+                bytes = Long.parseLong(freeSpace);
+            } catch (NumberFormatException ex) {
+                throw new IOException(
+                        "Command line 'df' did not return numeric data as expected " +
+                        "for path '" + path + "'- check path is valid");
+            }
 

@@ -212,6 +297,6 @@
 
-        if (bytes == -1) {
+        if (bytes < 0) {
             throw new IOException(
-                    "Command line 'df' did not find free space in response for path '" +
-                    path + "'- check path is valid");
+                    "Command line 'df' did not find free space in response " +
+                    "for path '" + path + "'- check path is valid");
         }

@@ -220,2 +305,14 @@
 
+    /**
+     * Opens the stream to be operating system.
+     *
+     * @param params  the command parameters
+     * @return a reader
+     */
+    protected BufferedReader openProcessStream(String[] params) throws IOException {
+        Process proc = Runtime.getRuntime().exec(params);
+        return new BufferedReader(
+            new InputStreamReader(proc.getInputStream()));
+    }
+
 }

