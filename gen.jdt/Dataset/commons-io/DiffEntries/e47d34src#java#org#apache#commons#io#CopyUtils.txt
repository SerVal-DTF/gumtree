Previous File: OUTPUT/commons-io/prevFiles/prev_e47d34src#java#org#apache#commons#io#CopyUtils.java
Revised File: OUTPUT/commons-io/revFiles/e47d34src#java#org#apache#commons#io#CopyUtils.java
DiffEntry: @@ -2,3 +2,3 @@
  * Copyright 2001-2004 The Apache Software Foundation.
- * 
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");

@@ -6,5 +6,5 @@
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software

@@ -28,20 +28,21 @@
 /**
- * <p>
- * This class provides static utility methods for buffered
- * copying between sources (<code>InputStream</code>, <code>Reader</code>, <code>String</code> and
- * <code>byte[]</code>) and destinations (<code>OutputStream</code>, <code>Writer</code>,
- * <code>String</code> and <code>byte[]</code>).
- * </p>
+ * <p>This class provides static utility methods for buffered
+ * copying between sources (<code>InputStream</code>, <code>Reader</code>,
+ * <code>String</code> and <code>byte[]</code>) and destinations
+ * (<code>OutputStream</code>, <code>Writer</code>, <code>String</code> and
+ * <code>byte[]</code>).</p>
  *
- * <p>Unless otherwise noted, these <code>copy</code> methods do <em>not</em> flush or close the
- * streams. Often doing so would require making non-portable assumptions about the streams' origin
- * and further use. This means that both streams' <code>close()</code> methods must be called after
- * copying. if one omits this step, then the stream resources (sockets, file descriptors) are
- * released when the associated Stream is garbage-collected. It is not a good idea to rely on this
- * mechanism. For a good overview of the distinction between "memory management" and "resource
- * management", see <a href="http://www.unixreview.com/articles/1998/9804/9804ja/ja.htm">this
+ * <p>Unless otherwise noted, these <code>copy</code> methods do <em>not</em>
+ * flush or close the streams. Often doing so would require making non-portable
+ * assumptions about the streams' origin and further use. This means that both
+ * streams' <code>close()</code> methods must be called after copying. if one
+ * omits this step, then the stream resources (sockets, file descriptors) are
+ * released when the associated Stream is garbage-collected. It is not a good
+ * idea to rely on this mechanism. For a good overview of the distinction
+ * between "memory management" and "resource management", see
+ * <a href="http://www.unixreview.com/articles/1998/9804/9804ja/ja.htm">this
  * UnixReview article</a>.</p>
  *
- * <p>For byte-to-char methods, a <code>copy</code> variant allows the encoding 
- * to be selected (otherwise the platform default is used). We would like to 
+ * <p>For byte-to-char methods, a <code>copy</code> variant allows the encoding
+ * to be selected (otherwise the platform default is used). We would like to
  * encourage you to always specify the encoding because relying on the platform

@@ -53,8 +54,9 @@
  *
- * <p>The <code>copy</code> methods use an internal buffer when copying. It is therefore advisable
- * <em>not</em> to deliberately wrap the stream arguments to the <code>copy</code> methods in
- * <code>Buffered*</code> streams. For example, don't do the
- * following:</p>
+ * <p>The <code>copy</code> methods use an internal buffer when copying. It is
+ * therefore advisable <em>not</em> to deliberately wrap the stream arguments
+ * to the <code>copy</code> methods in <code>Buffered*</code> streams. For
+ * example, don't do the following:</p>
  *
- * <code>copy( new BufferedInputStream( in ), new BufferedOutputStream( out ) );</code>
+ * <code>copy( new BufferedInputStream( in ),
+ *   new BufferedOutputStream( out ) );</code>
  *

@@ -62,11 +64,16 @@
  *
- * <p>Imagine that an InputStream's read() is a very expensive operation, which would usually suggest
- * wrapping in a BufferedInputStream. The BufferedInputStream works by issuing infrequent
- * {@link java.io.InputStream#read(byte[] b, int off, int len)} requests on the underlying InputStream, to
- * fill an internal buffer, from which further <code>read</code> requests can inexpensively get
- * their data (until the buffer runs out).</p>
- * <p>However, the <code>copy</code> methods do the same thing, keeping an internal buffer,
- * populated by {@link InputStream#read(byte[] b, int off, int len)} requests. Having two buffers
- * (or three if the destination stream is also buffered) is pointless, and the unnecessary buffer
- * management hurts performance slightly (about 3%, according to some simple experiments).</p>
+ * <p>Imagine that an InputStream's read() is a very expensive operation, which
+ * would usually suggest wrapping in a BufferedInputStream. The
+ * BufferedInputStream works by issuing infrequent
+ * {@link java.io.InputStream#read(byte[] b, int off, int len)} requests on the
+ * underlying InputStream, to fill an internal buffer, from which further
+ * <code>read</code> requests can inexpensively get their data (until the buffer
+ * runs out).</p>
+ *
+ * <p>However, the <code>copy</code> methods do the same thing, keeping an
+ * internal buffer, populated by
+ * {@link InputStream#read(byte[] b, int off, int len)} requests. Having two
+ * buffers (or three if the destination stream is also buffered) is pointless,
+ * and the unnecessary buffer management hurts performance slightly (about 3%,
+ * according to some simple experiments).</p>
  *

@@ -100,6 +107,7 @@
  * @author Matthew Hawthorne
- * @version $Id: CopyUtils.java,v 1.9 2004/08/13 23:51:41 scolebourne Exp $
+ * @version $Id: CopyUtils.java,v 1.10 2004/10/24 04:20:06 martinc Exp $
  * @deprecated Use IOUtils. Will be removed in 2.0.
  *  Methods renamed to IOUtils.write() or IOUtils.copy().
- *  Null handling behaviour changed in IOUtils (null data does not throw NullPointerException).
+ *  Null handling behaviour changed in IOUtils (null data does not
+ *  throw NullPointerException).
  */

@@ -115,3 +123,3 @@
      */
-    public CopyUtils() {}
+    public CopyUtils() { }
 

@@ -176,3 +184,4 @@
     /**
-     * Copy bytes from an <code>InputStream</code> to an <code>OutputStream</code>.
+     * Copy bytes from an <code>InputStream</code> to an
+     * <code>OutputStream</code>.
      * @param input the <code>InputStream</code> to read from

@@ -266,3 +275,3 @@
     /**
-     * Serialize chars from a <code>Reader</code> to bytes on an 
+     * Serialize chars from a <code>Reader</code> to bytes on an
      * <code>OutputStream</code>, and flush the <code>OutputStream</code>.

@@ -278,3 +287,4 @@
         copy(input, out);
-        // XXX Unless anyone is planning on rewriting OutputStreamWriter, we have to flush here.
+        // XXX Unless anyone is planning on rewriting OutputStreamWriter, we
+        // have to flush here.
         out.flush();

@@ -287,3 +297,4 @@
     /**
-     * Serialize chars from a <code>String</code> to bytes on an <code>OutputStream</code>, and
+     * Serialize chars from a <code>String</code> to bytes on an
+     * <code>OutputStream</code>, and
      * flush the <code>OutputStream</code>.

@@ -300,3 +311,4 @@
         copy(in, out);
-        // XXX Unless anyone is planning on rewriting OutputStreamWriter, we have to flush here.
+        // XXX Unless anyone is planning on rewriting OutputStreamWriter, we
+        // have to flush here.
         out.flush();

